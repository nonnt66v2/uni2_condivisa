Costruzioni sicure
Paolo D‚ÄôArco
pdarco@unisa.it
Universit√† di Salerno

Elementi di Crittografia

Paolo D‚ÄôArco (Unisa)

Costruzioni sicure

EC-2025

1 / 31

Contenuti

1

Generatori pseudocasuali e stream cipher

2

Pseudocasualit√†

3

Riduzioni

4

Costruzione sicura

Paolo D‚ÄôArco (Unisa)

Costruzioni sicure

EC-2025

2 / 31

Costruzioni di schemi di cifratura sicuri

Abbiamo bisogno di blocchi di base:
Generatori pseudocasuali (pseudorandom generator, PRG)
Un generatore pseudocasuale G √® un algoritmo deterministico efficiente per
trasformare una stringa uniforme corta, chiamata seme, in una pi√π lunga
che sembra uniforme
Studiati a partire dagli anni 0 40
progettati per superare test statistici ad hoc: primo bit, parit√†, ...
nessuna garanzia di robustezza in specifiche applicazioni

Paolo D‚ÄôArco (Unisa)

Costruzioni sicure

EC-2025

3 / 31

Generatori pseudocasuali: approccio

Approccio crittografico negli anni 0 80
un generatore pseudocasuale buono dovrebbe superare tutti i test
statistici efficienti
ad ogni osservatore efficiente l‚Äôoutput dovrebbe sembrare una stringa
uniforme
Nota: usiamo le espressioni stringa pseudorandom/pseudocasuale e stringa
uniforme con abuso della terminologia.
pseudocasualit√†: propriet√† di una distribuzione di stringhe
uniformit√†: propriet√† di una distribuzione di stringhe

Paolo D‚ÄôArco (Unisa)

Costruzioni sicure

EC-2025

4 / 31

Distribuzione pseudocasuale

Che cosa significa per una distribuzione di probabilit√† essere pseudocasuale?
Sia Dist una distribuzione su stringhe di ` bit. √à pseudocasuale
se l‚Äôesperimento in cui una stringa viene campionata in accordo a Dist
√® indistinguibile dall‚Äôesperimento in cui una stringa di lunghezza `
viene campionata in accordo alla distribuzione uniforme
Risulta, cio√®, impossibile per ogni algoritmo PPT dire, con chance
significativamente migliori di quelle offerte dal lancio di una moneta, se
essa derivi da Dist o dalla distribuzione uniforme
Discende che una stringa pseudocasuale √® tanto buona quanto una
uniforme.

Paolo D‚ÄôArco (Unisa)

Costruzioni sicure

EC-2025

5 / 31

Generatore pseudocasuale (informale)

Sia G : {0, 1}n ‚Üí {0, 1}` e sia Dist la distribuzione sulle stringhe di ` bit
ottenuta
scegliendo uniformemente a caso s ‚àà {0, 1}n
dando in output G (s)
G √® PRG se e solo se Dist √® pseudocasuale.

Paolo D‚ÄôArco (Unisa)

Costruzioni sicure

EC-2025

6 / 31

Generatore pseudocasuale (formale)
Definizione 3.14. Sia `(n) un polinomio e G un algoritmo deterministico di
tempo polinomiale tale che, per ogni n ed s ‚àà {0, 1}n , G (s) √® una stringa
di `(n) bit. Diremo che G √® un PRG se valgono le seguenti condizioni:
1

Espansione: per ogni n risulta `(n) > n

2

Pseudocasualit√†: per ogni algoritmo D PPT, esiste una funzione
trascurabile negl(n) tale che
|Pr [D(G (s)) = 1] ‚àí Pr [D(r ) = 1]| ‚â§ negl(n)

dove la prima probabilit√† √® calcolata su
scelta uniforme di s ‚àà {0, 1}n
random bit di D

Paolo D‚ÄôArco (Unisa)

e la seconda su
scelta uniforme di
r ‚àà {0, 1}`(n)
random bit di D

Costruzioni sicure

EC-2025

7 / 31

Una costruzione non sicura
Esempio 3.15. Sia G : {0, 1}n ‚Üí {0, 1}n+1 tale che G (s) = s||

Ln

i=1 si .

Distinguisher D:
su input œâ d√† in output 1 se e solo se il bit finale di œâ √® l‚Äô xor di tutti
i precedenti.
Risulta:
se l‚Äôinput di D √® G (s), allora Pr [D(G (s)) = 1] = 1
se l‚Äôinput di D √® r , allora Pr [D(r ) = 1] = 1/2
la probabilit√† che l‚Äôultimo bit sia uguale all‚Äôxor dei precedenti √® 1/2
perch√® r viene scelta in modo uniforme in {0, 1}n+1

Poich√® la differenza √®
|Pr [D(G (s)) = 1] ‚àí Pr [D(r ) = 1]| = |1 ‚àí 1/2| = 1/2,
costante (non trascurabile), G non √® pseudocasuale.
Paolo D‚ÄôArco (Unisa)

Costruzioni sicure

EC-2025

8 / 31

Osservazioni

La distribuzione sugli output di un generatore pseudocasuale G √® lontana
da quella uniforme. Per rendersene conto, sia `(n) = 2n. Allora
G : {0, 1}n ‚Üí {0, 1}2n .
Poich√® ci sono 2n possibili semi, G pu√≤ generare al pi√π 2n delle 22n possibili
stringhe.
Equivalentemente, la frazione di stringhe di 2n bit che G pu√≤ generare √®
2n /22n = 1/2n .
Si consideri il seguente esempio, in cui n = 4

Paolo D‚ÄôArco (Unisa)

Costruzioni sicure

EC-2025

9 / 31

Osservazioni

Nell‚Äôesempio G pu√≤ generare soltanto 24 = 16 stringhe di 8 bit,
dell‚Äôuniverso delle possibili 28 = 256 stringhe di 8 bit. La stragrande
maggioranza non pu√≤ essere generata.

Paolo D‚ÄôArco (Unisa)

Costruzioni sicure

EC-2025

10 / 31

Osservazioni

Data una quantit√† illimitata di tempo √® pertanto banale distinguere.
Un distinguisher D di tempo esponenziale tenta tutti i semi s ‚àà {0, 1}n e
d√† in output 1 se e solo se G (s) = œâ per qualche s.
Si noti che, presa una stringa œâ uniforme in {0, 1}2n , risulta
Pr [G (s) = œâ] ‚â§ 1/2n . Pertanto
|Pr [D(G (s)) = 1] ‚àí Pr [D(r ) = 1]| = 1 ‚àí 1/2n non trascurabile.
Quindi D distingue attraverso una ricerca esaustiva del seme in s ‚àà {0, 1}n .
Ci√≤ non contraddistingue la pseudocasualit√† di G perch√® D non √®
efficiente computazionalmente.

Paolo D‚ÄôArco (Unisa)

Costruzioni sicure

EC-2025

11 / 31

Osservazioni
Il seme di G equivale alla chiave in uno schema di cifratura simmetrico
deve essere scelto in modo uniforme e tenuto segreto
abbastanza lungo da evitare ricerche esaustive
La lunghezza del seme equivale al parametro di sicurezza.

Domanda: ma esistono generatori pseudocasuali?
Nessuna prova incondizionata, prova sotto assunzioni.
Se esistono funzioni one-way (a senso unico), allora esistono PRG (... ci
torneremo).
In pratica abbiamo buone costruzioni che utilizzano stream cipher.

Paolo D‚ÄôArco (Unisa)

Costruzioni sicure

EC-2025

12 / 31

Stream cipher

La definizione di PRG ha due limitazioni
il fattore di espansione √® fisso
l‚Äôintero output viene prodotto tutto d‚Äôun colpo
Al contrario, uno stream cipher
non ha un limite al fattore di espansione
produce bit di output gradualmente
Stream cipher: coppia di algoritmi (Init, GetBits) deterministici, dove
Init(s, IV ) d√† in output uno stato iniziale s0
GetBits(sti‚àí1 ) d√† in output (sti , y ) (prox stato, bit/stringa di bit)

Paolo D‚ÄôArco (Unisa)

Costruzioni sicure

EC-2025

13 / 31

PRG da uno stream cipher

Dato uno stream cipher ed un fattore di espansione `, possiamo definire
G` : {0, 1}n ‚Üí {0, 1}` come segue:

Paolo D‚ÄôArco (Unisa)

Costruzioni sicure

EC-2025

14 / 31

Sicurezza di uno stream cipher

Uno stream cipher √® sicuro (in un senso di base) se non prende in input IV
e, per ogni polinomio `(n) > n, la funzione G` √® un generatore
pseudocasuale con fattore di espansione `.

In altre parole, lo stream cipher √® sicuro se G` √® un PRG

Nelle prossime lezioni vedremo alcune costruzioni usate in pratica di stream
cipher.

Paolo D‚ÄôArco (Unisa)

Costruzioni sicure

EC-2025

15 / 31

Prove (dimostrazioni) per riduzione
Provare che una costruzione √® computazionalmente sicura significa
far affidamento su assunzioni (aff. non provate, congetturate vere)
un problema matematico √® difficile
qualche primitiva crittografica √® sicura

provare che, basandosi sulle assunzioni fatte, la costruzione risulta
sicura.
Generalmente procederemo come segue:
Presenteremo una riduzione esplicita che mostra come trasformare un Adv
efficiente A che ha successo nel rompere la costruzione data in un Adv
efficiente A0 che
risolve il problema matematico supposto difficile
rompe la primitiva crittografica assunta sicura
Paolo D‚ÄôArco (Unisa)

Costruzioni sicure

EC-2025

16 / 31

Struttura di una riduzione

Cominciamo con una assunzione: il problema X √® difficile, i.e., non pu√≤
essere risolto con algoritmi PPT.
Vogliamo provare che la costruzione Œ† √® sicura
Paolo D‚ÄôArco (Unisa)

Costruzioni sicure

EC-2025

17 / 31

Struttura di una riduzione

1

2

Fissiamo un Adv A PPT che attacca Œ† con probabilit√† di successo
(n)
Costruiamo A0 PPT (detto la riduzione) che risolve X usando A come
subroutine. A0 non conosce il funzionamento interno di A; sa solo che
serve ad attaccare Œ†.
Quindi, data x, un‚Äôistanza di X , A0 simula per A un‚Äôistanza della
costruzione Œ† (in cui immerge x) in modo tale che:
1

2

A pensa di star interagendo con Œ†, i.e., ha la stessa vista (o molto
simile) che ha quando interagisce realmente con Œ†
se A ha successo nel rompere Œ† sull‚Äôistanza che ha ricevuto da A0 ,
allora A0 risolve l‚Äôistanza x del problema X che ha ricevuto in input con
probabilit√† almeno 1/p(n)

Paolo D‚ÄôArco (Unisa)

Costruzioni sicure

EC-2025

18 / 31

Struttura di una riduzione

3. Le condizioni 2.1 e 2.2 implicano che
A0 risolve X con probabilit√† almeno (n)/p(n). Pertanto, se (n) √® non
trascurabile, anche (n)/p(n) √® non trascurabile
A0 √® efficiente se A √® efficiente.

4. Data l‚Äôassunzione di difficolt√† sul problema X , concludiamo che nessun
Adv A PPT pu√≤ avere successo nel rompere Œ† con probabilit√† non
trascurabile. Quindi, Œ† √® computazionalmente sicuro.
Costruiremo ora uno schema di cifratura utilizzando un PRG ed
esemplificheremo la tecnica provandone la sicurezza.

Paolo D‚ÄôArco (Unisa)

Costruzioni sicure

EC-2025

19 / 31

Cifratura sicura con un PRG per messaggi di lunghezza fissa
Idea:
il one-time pad cifra tramite m ‚äï r , con r stringa scelta
uniformemente a caso
qui invece cifriamo tramite m ‚äï G (s), con G (s) stringa pseudocasuale
le parti devono condividere il seme (chiave segreta)

Paolo D‚ÄôArco (Unisa)

Costruzioni sicure

EC-2025

20 / 31

Cifratura sicura con un PRG

Per ogni k ‚àà {0, 1}n e per ogni m ‚àà {0, 1}` , risulta:
G (k) ‚äï c = G (k) ‚äï (G (k) ‚äï m) = m

Paolo D‚ÄôArco (Unisa)

Costruzioni sicure

EC-2025

21 / 31

Cifratura sicura con un PRG
Teorema 3.16 Se G √® un PRG, la Costruzione 3.17 realizza uno schema di
cifratura a chiave privata per messaggi di lunghezza fissa che ha cifrati
indistinguibili in presenza di un eavesdropper.
Dim. Facciamo vedere che, per ogni Adv A PPT, esiste una fun. tras.
negl(n) tale che
eav
Pr [PrivKA,Œ†
(n) = 1] ‚â§ 1/2 + negl(n).

Intuizione della prova:
se Œ† usasse un pad uniforme invece di G (k), Œ† sarebbe identico allo
schema one-time pad ed A vincerebbe nell‚Äôesperimento con prob. 1/2
pertanto, se A fosse in grado di vincere nel nostro caso con probabilit√†
significativamente maggiore di 1/2, allora A potrebbe essere usato per
distinguere G (k) da una stringa uniforme
Paolo D‚ÄôArco (Unisa)

Costruzioni sicure

EC-2025

22 / 31

Cifratura sicura con un PRG
Procediamo formalmente, esibendo la riduzione.
Costruiamo D che distingue G (k) da r , utilizzando A e la sua abilit√† nel
capire quale messaggio tra m0 ed m1 √® stato cifrato
Probabilit√† di successo di D relata alla probabilit√† di successo di A.

Distinguisher D:
Riceve in input una stringa œâ ‚àà {0, 1}`(n)
1

esegue A(1n ) per ottenere m0 , m1 ‚àà {0, 1}`(n)

2

sceglie uniformemente b ‚àà {0, 1} e pone c := mb ‚äï œâ

3

d√† c ad A ed ottiene da A il bit b 0

4

se b 0 = b, d√† in output 1; altrimenti, d√† in output 0

Paolo D‚ÄôArco (Unisa)

Costruzioni sicure

EC-2025

23 / 31

Cifratura sicura con un PRG

Osservazioni:
eav (n) per A ed osserva se A ha successo
D emula l‚Äôesperimento PrivKA,Œ†
o meno. Nel primo caso, D pensa che œâ debba essere pseudocasuale;
nel secondo, uniforme.

D √® PPT se A √® un Adv PPT.
‚àº

‚àº

‚àº

‚àº

Al fine di analizzare D, definiamo lo schema Œ†= (Gen, Enc, Dec).
‚àº

√à esattamente il one-time pad: Gen (1n ) riceve in input il parametro di
sicurezza n e d√† in output una chiave uniforme k ‚àà {0, 1}`(n)
‚àº

La segretezza perfetta di Œ†

Paolo D‚ÄôArco (Unisa)

‚áí

Pr [PrivK eav‚àº (n) = 1] = 1/2.

Costruzioni sicure

A,Œ†

EC-2025

24 / 31

Cifratura sicura con un PRG
Ora, segue che:
1 se œâ √® una stringa uniforme in {0, 1}`(n) allora
la vista di A quando eseguito come subroutine da D = la vista di A in
PrivK eav‚àº (n)
A,Œ†

poich√® D d√† in output 1 quando A ha successo, risulta
Prœâ‚Üê{0,1}`(n) [D(œâ) = 1] = Pr [PrivK eav‚àº (n) = 1] = 1/2.
A,Œ†

2

se, invece, œâ = G (k), dove k √® una stringa uniforme in {0, 1}n allora
la vista di A quando eseguito come subroutine da D = la vista di A in
eav
PrivKA,Œ†
(n)
poich√® D d√† in output 1 quando A ha successo, risulta
eav
Prk‚Üê{0,1}n [D(G (k)) = 1] = Pr [PrivKA,Œ†
(n) = 1].

Paolo D‚ÄôArco (Unisa)

Costruzioni sicure

EC-2025

25 / 31

Cifratura sicura con un PRG
eav (n) = 1] = 1/2 + non-negl(n) allora
Se risultasse Pr [PrivKA,Œ†
eav
|Pr [PrivK eav‚àº (n) = 1] ‚àí Pr [PrivKA,Œ†
(n) = 1]|
A,Œ†

= |1/2 ‚àí (1/2 + non-negl(n))| = non-negl(n)
cio√©, per le precedenti,
|Prœâ‚Üê{0,1}`(n) [D(œâ) = 1] ‚àí Prk‚Üê{0,1}n [D(G (k)) = 1]| = non-negl(n).
Dunque D √© PPT e distingue con probabilit√° non-negl(n)! Ma G per
ipotesi √® un PRG. Pertanto, non pu√≥ essere. Deve esistere negl(n) tale che
|Prœâ‚Üê{0,1}`(n) [D(œâ) = 1] ‚àí Prk‚Üê{0,1}n [D(G (k)) = 1]| ‚â§ negl(n)
che implica
eav
Pr [PrivKA,Œ†
(n) = 1] ‚â§ 1/2 + negl(n).

4
Paolo D‚ÄôArco (Unisa)

Costruzioni sicure

EC-2025

26 / 31

Semplificazione della prova: alternativa alla slide precedente
G per ipotesi √® un PRG e D √® PPT. Pertanto, esiste negl(n) tale che
|Prœâ‚Üê{0,1}`(n) [D(œâ) = 1] ‚àí Prk‚Üê{0,1}n [D(G (k)) = 1]| ‚â§ negl(n).
Ma allora,
eav
|Pr [PrivK eav‚àº (n) = 1] ‚àí Pr [PrivKA,Œ†
(n) = 1]| ‚â§ negl(n),
A,Œ†

ovvero
eav
|1/2 ‚àí Pr [PrivKA,Œ†
(n) = 1]| ‚â§ negl(n),

che implica
eav
Pr [PrivKA,Œ†
(n) = 1] ‚â§ 1/2 + negl(n).

Poich√® A √® un Adv PPT arbitrario, possiamo concludere che Œ† ha cifrati
indistinguibili in presenza di un eavesdropper. 4
Paolo D‚ÄôArco (Unisa)

Costruzioni sicure

EC-2025

27 / 31

Commenti
Commenti:
la dimostrazione non √® incondizionata. Œ† √® sicuro se G √® un PRG
abbiamo ridotto il problema di rompere il G al problema di rompere Œ†
l‚Äôapproccio che consiste nel basare la sicurezza di costruzioni di alto
livello su costruzioni di basso livello ha diversi vantaggi
√® pi√π facile progettare primitive di basso livello
√® pi√π facile l‚Äôanalisi rispetto ad una definizione pi√π semplice
una buona primitiva pu√≤ essere usata in molte costruzioni di alto livello

Quale vantaggio abbiamo rispetto al one-time pad?
Una chiave k di pochi bit, e.g., 128, permette di cifrare messaggi
molto lunghi, e.g., di 1 GB

Paolo D‚ÄôArco (Unisa)

Costruzioni sicure

EC-2025

28 / 31

Limitazione concreta
Come derivare una limitazione concreta alla sicurezza di Œ† usando una
limitazione concreta alla sicurezza di G ?
Fissiamo n e assumiamo che G sia (t, )-pseudocasuale per questo n.
‚áí ‚àÄD che esegue in tempo al pi√π t,
|Pr [D(r ) = 1] ‚àí Pr [D(G (s)) = 1]| ‚â§ .
Per esempio, potremmo avere t ‚âà 280 ed  ‚âà 2‚àí60 .
Possiamo far vedere che Œ† √® (t ‚àí c, )-EAV-sicuro per qualche costante c
piccola, i.e., ‚àÄA che esegue in tempo al pi√π t ‚àí c, risulta
eav
Pr [PrivKA,Œ†
(n) = 1] ‚â§ 1/2 + .

Paolo D‚ÄôArco (Unisa)

Costruzioni sicure

EC-2025

29 / 31

Limitazione concreta
Infatti, sia A un avversario arbitrario di tempo al pi√π t ‚àí c. Il distinguisher
D che abbiamo costruito fa ben poco oltre ad invocare A ed eseguirlo.
Ponendo c al valore opportuno per tener conto del lavoro aggiuntivo di D,
risulta il tempo totale di esecuzione di D al pi√π (t ‚àí c) + c = t.
L‚Äôassunzione che G sia un PRG implica che
|Pr [D(r ) = 1] ‚àí Pr [D(G (s)) = 1]| ‚â§ 
e, quindi, ripetendo gli stessi passi della riduzione, si ottiene che
eav
Pr [PrivKA,Œ†
(n) = 1] ‚â§ 1/2 + .

Nota che stiamo parlando di valori concreti. Il parametro di sicurezza n √®
fissato all‚Äôinizio e la valutazione √® per valori specifici, non asintotica.
Paolo D‚ÄôArco (Unisa)

Costruzioni sicure

EC-2025

30 / 31

Appendice: visualizzazione prova

Paolo D‚ÄôArco (Unisa)

Costruzioni sicure

EC-2025

31 / 31

